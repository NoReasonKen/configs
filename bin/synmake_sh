#!/u/chehuang/bin/bash

help="Usage: synmake_sh <OPTION>...
Supports short keys for usual synmake commands, only works when run in client root
options:
    -P, --preset <ENUM>     Use preset enums. They are order irrelevant, and any explicit declared
                            params will override params in preset.
                            S(simple)='-c <Client Root>/.compile_commands.json -l <Client Root>/.synmake.log'
                            I='--install'
                            A='--always-make' or '-B'
                            R='--build-type release'
                            G='--build-type debug'
                            D='--build-type develop'
                            P='--prebuild'
                            p='--pack'
                            E.G. 'synmake_sh -c test.json -P SA -l test.log' ===
                                 'synmake_sh -c test.json -l test.log -t -B'
    ---------------------------------------------------------------------------------
    -m, --module <MODULE>   Specify module, can be {All, PW}
                            [Default=All]
    -t, --build-type        Build type
                            'R|release': Release build
                            'G|debug': Debug build
                            'D|develop': Develop build [Default]
    -P, --prebuild          Run prebuild before build (only for cc)
    -i, --install           Build
    -p, --pack              Pack packages after build success
    -B, --always-make       Unconditionally make all targets
    -c, --compdb <FILE>     Output compdb file name
    -l, --log <FILE>        Output log file name
    -s, --summary           Whether output summary of log file after build success
    --dry-run               Only show the constructed command instead of running it
    -v, --verbose           Show verbose messages in console
    -h, --help              Display this help and exit
"

source "/u/chehuang/bin/utils_src"
PATH=/u/chehuang/bin:$PATH

MODULES=("All" "PW")

preset=""
module="All"
build_type=""
prebuild=false
install=false
pack=false
always_make=false
compdb=""
log_file=""
is_summary=false
dry_run=false
verbose=false

if [[ "$(pwd)" != $(p4 -z tag -F %clientRoot% info) ]]; then
    utils::ERROR "synmake_sh can only run in client root\n" >&2
    exit 1
fi

original_args=( "$@" )
while [[ $# -gt 0 ]]; do
    case $1 in
        -P|--preset)
            shift; preset=$1; shift
            break
            ;;
        *)
            shift
            ;;
    esac
done

while read -rn 1 ch; do
    case $ch in
        S)
            compdb=".compile_commands.json"
            log_file=".synmake.log"
            is_summary=true
            ;;
        I)
            install=true
            ;;
        A)
            always_make=true
            ;;
        R)
            build_type=release
            ;;
        G)
            build_type=debug
            ;;
        D)
            build_type=develop
            ;;
        P)
            prebuild=true
            ;;
        p)
            pack=true
            ;;
        *)
            utils::ERROR "Invalid preset '$ch'\n" >&2
            exit 1
            ;;
    esac
done < <(echo -n "$preset")

set -- "${original_args[@]}"
while [[ $# -gt 0 ]]; do
    case $1 in
        -P|--preset)
            shift; shift
            ;;
        -m|--module)
            shift
            # shellcheck disable=SC2076
            if [[ ! " ${MODULES[@]} " =~ " $1 " ]]; then
                utils::ERROR "Invalid module, valid modules: (${MODULES[*]})\n" >&2
                exit 1
            fi
            module=$1
            shift
            ;;
        -t|--build-type)
            shift
            case "$1" in
                R|release|G|debug|D|develop)
                    ;;
                *)
                    utils::ERROR "Invalid build type '$1'\n" >&2
                    exit 1
                    ;;
            esac
            build_type=$1
            shift
            ;;
        -b|--prebuild)
            prebuild=true; shift
            ;;
        -i|--install)
            install=true; shift
            ;;
        -p|--pack)
            pack=true; shift
            ;;
        -B|--always-make)
            always_make=true; shift
            ;;
        -c|--compdb)
            shift
            if [[ -e "$1" && ! -f "$1" ]]; then
                utils::ERROR "compdb exists and is not a file\n" >&2
                exit 1
            fi
            compdb=$1
            shift
            ;;
        -l|--log)
            shift
            if [[ -e "$1" && ! -f "$1" ]]; then
                utils::ERROR "log-file exists and is not a file\n" >&2
                exit 1
            fi
            log_file=$1
            shift
            ;;
        -s|--summary)
            is_summary=true; shift
            ;;
        --dry-run)
            dry_run=true; shift
            ;;
        -v|--verbose)
            verbose=true; shift
            ;;
        -h|--help)
            echo "$help" && exit 0
            ;;
        *)
            utils::ERROR "Unknown parameter '$1'\n" >&2
            exit 1
            ;;
    esac
done

if [[ "$module" != "All" ]]; then
    compdb=""
    utils::verbose -c "${BRED}" -p "* " "Ignore parameter '-compdb' because it only build specific" \
        "module\n"
fi

case "$build_type" in
    R|release)
        build_type="r"
        ;;
    G|debug)
        build_type="g"
        compdb=""
        utils::verbose -c "${BRED}" -p "* " \
            "Ignore parameter '-compdb' because it's a debug build\n"
        ;;
    ""|D|develop)
        build_type="d"
        ;;
esac
[[ -n "$log_file" ]] && log_file="${log_file%.*}.${build_type}.${log_file##*.}"

utils::verbose -c "${CYAN}" \
    "module=$module; build-type=$build_type; prebuild=$prebuild; install=$install; pack=$pack; " \
    "always-make=$always_make; compdb=$compdb; log=$log_file; summary=$is_summary\n"

client_name="$(p4 -z tag -F %clientName% info)"
if [[ "$client_name" == "none" || "$client_name" == "\*unknown\*" ]]; then
    utils::ERROR "Missing P4 Client\n" >&2
    exit 1
fi

client_root="$(p4 -z tag -F %clientRoot% info)"

#--------------------
# prebuild
prebuild_cmd=""
if [[ "$prebuild" == true ]]; then
    if [[ "$module" != "PW" ]]; then
        if [[ -n "$log_file" ]]; then
            prebuild_cmd=" -log \"${log_file%.*}.prebuild.${log_file##*.}\""
        fi
        prebuild_cmd="synmake$prebuild_cmd prebuild"

        utils::verbose -f -c "${BGREEN}" -p "* " "Prebuilding ...\n"
        utils::verbose "  $prebuild_cmd\n"
        if [[ "$dry_run" == false ]]; then
            if bash -c "$prebuild_cmd"; then
                utils::verbose -f -c "${CYAN}" "  [$(date +"%Y-%m-%d %H:%M:%S")]\n"
            else
                utils::ERROR "Prebuild fail\n" >&2
                exit 1
            fi
        fi
    else
        utils::WARNING "Can't apply prebuild to module 'PW', ignore\n" >&2
    fi
fi

#--------------------
# build
build_cmd=""
build_status=0

if [[ "$install" == true ]]; then
    build_options=""
    if [[ "$module" == "PW" ]]; then
        [[ ! -d primewave ]] && { utils::ERROR "Missing 'primewave' folder\n" >&2; exit 1; }
        build_options+=" -C primewave"
    fi

    if [[ "$always_make" == true ]]; then
        build_options+=" -B"
    fi

    if [[ -n "$compdb" ]]; then
        build_options+=" -compdb \"$(utils::get_relative_path -d 2 "$(pwd)" "$compdb")\""
    fi

    if [[ -n "$log_file" ]]; then
        build_options+=" -log \"$(utils::get_relative_path -d 2 "$(pwd)" "$log_file")\""
    fi

    build_cmd+="synmake$build_options install"
    case "$build_type" in
        g|d)
            build_cmd+="-$build_type"
            ;;
    esac

    utils::verbose -f -c "${BGREEN}" -p "* " "Building ...\n"
    utils::verbose "  $build_cmd\n"
    if [[ "$dry_run" == false ]]; then
        bash -c "$build_cmd"
        build_status=$?

        # Overwrite compile_commands.json if it's fully build
        status_code=$?
        if [[ "$always_make" == true && "$status_code" == 0 ]] ; then
            if [[ "$build_type" != "g" ]]; then
                [[ -n "$compdb" && -e "$compdb" ]] && cp "$compdb" "$client_root/compile_commands.json"
                # Our make file set some of compile variable with escape on double quote which is
                #   meaningless and make clangd can't parse macro 'ASSERT_RETURN' correctly
                # Here replace \\\"VALUE\\\" to \"VALUE\"
                sed -i 's|\\\\\\"|\\"|g' "$client_root/compile_commands.json"
            fi
        fi

        # Remove .smk_compdb_* because it makes next synmake run generate weird error messages
        rm "$client_root/.smk_compdb_"* 2> /dev/null

        utils::verbose -f -c "${CYAN}" "  [$(date +"%Y-%m-%d %H:%M:%S")]\n"
    fi
fi

#--------------------
# tail
if [[ -n "$build_cmd" && -n "$log_file" && "$is_summary" == true ]]; then
    utils::verbose -f -c "${BGREEN}" -p "* " "$log_file:\n"
    utils::verbose "  tail -n +<Auto Detect> $log_file\n"
    if [[ "$dry_run" == false ]]; then
        if [[ "$build_status" -eq 0 ]]; then
            tail -n +"$(rg --case-sensitive --line-number "List of" "$log_file" | cut -d ':' -f 1)" "$log_file"
        else
            tail -n 250 "$log_file" | rg -B 1 -M 0 -i "(^| )error"; tail -n 2 "$log_file"
        fi
    fi
fi
[[ "$build_status" -eq 0 ]] || exit 1

#--------------------
# pack command
pack_cmd=""
if [[ "$pack" == true ]]; then
    utils::verbose -f -c "${BGREEN}" -p "* " "Packing ...\n"
    pack_cmd="synmake -C primewave"
    if [[ -n "$log_file" ]]; then
        _log_file="$(utils::get_relative_path -d 2 "$(pwd)/primewave" "$log_file")"
        pack_cmd+=" -log \"${_log_file%.*}.pack.${_log_file##*.}\""
    fi

    case "$build_type" in
        r)
            pack_cmd+=" optpack"
            ;;
        g)
            pack_cmd+=" dbgpack"
            ;;
        d)
            pack_cmd+=" devpack"
            ;;
    esac

    utils::verbose "  $pack_cmd\n"
    if [[ "$dry_run" == false ]]; then
        if bash -c "$pack_cmd"; then
            utils::verbose -f -c "${CYAN}" "  [$(date +"%Y-%m-%d %H:%M:%S")]\n"
        else
            utils::ERROR "Pack fail\n" >&2
            exit 1
        fi
    fi
fi

exit 0

